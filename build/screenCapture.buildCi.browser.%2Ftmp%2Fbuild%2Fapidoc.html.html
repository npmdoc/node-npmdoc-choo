<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/yoshuawuyts/choo#readme">choo (v5.3.0)</a>
</h1>
<h4>A 4kb framework for creating sturdy frontend applications</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.choo">module choo</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.choo.choo">
            function <span class="apidocSignatureSpan"></span>choo
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.choo.html">
            function <span class="apidocSignatureSpan">choo.</span>html
            <span class="apidocSignatureSpan">(strings)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.choo.html">module choo.html</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.choo.html.html">
            function <span class="apidocSignatureSpan">choo.</span>html
            <span class="apidocSignatureSpan">(strings)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.choo.html.createElement">
            function <span class="apidocSignatureSpan">choo.html.</span>createElement
            <span class="apidocSignatureSpan">(tag, props, children)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.choo.html.default">
            function <span class="apidocSignatureSpan">choo.html.</span>default
            <span class="apidocSignatureSpan">(strings)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.choo" id="apidoc.module.choo">module choo</a></h1>


    <h2>
        <a href="#apidoc.element.choo.choo" id="apidoc.element.choo.choo">
        function <span class="apidocSignatureSpan"></span>choo
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Choo(opts) {
  opts = opts || {}

  var routerOpts = {
    default: opts.defaultRoute || '/404',
    curry: true
  }

  var timingEnabled = opts.timing === undefined ? true : opts.timing
  var hasWindow = typeof window !== 'undefined'
  var hasPerformance = hasWindow &amp;&amp; window.performance &amp;&amp; window.performance.mark
  var router = nanorouter(routerOpts)
  var bus = nanobus()
  var rerender = null
  var tree = null
  var state = {}

  return {
    toString: toString,
    use: register,
    mount: mount,
    router: router,
    route: route,
    start: start
  }

  function route (route, handler) {
    router.on(route, function (params) {
      return function () {
        state.params = params
        return handler(state, emit)
      }
    })
  }

  function register (cb) {
    cb(state, bus)
  }

  function start () {
    tree = router(createLocation())
    rerender = nanoraf(function () {
      if (hasPerformance &amp;&amp; timingEnabled) {
        window.performance.mark('choo:renderStart')
      }
      var newTree = router(createLocation())
      tree = nanomorph(tree, newTree)
      if (hasPerformance &amp;&amp; timingEnabled) {
        window.performance.mark('choo:renderEnd')
        window.performance.measure('choo:render', 'choo:renderStart', 'choo:renderEnd')
      }
    })

    bus.prependListener('render', rerender)

    if (opts.history !== false) {
      nanohistory(function (href) {
        bus.emit('pushState')
      })

      bus.prependListener('pushState', function (href) {
        if (href) window.history.pushState({}, null, href)
        bus.emit('render')
        setTimeout(function () {
          scrollIntoView()
        }, 0)
      })

      if (opts.href !== false) {
        nanohref(function (location) {
          var href = location.href
          var currHref = window.location.href
          if (href === currHref) return
          bus.emit('pushState', href)
        })
      }
    }

    documentReady(function () {
      bus.emit('DOMContentLoaded')
    })

    return tree
  }

  function emit (eventName, data) {
    bus.emit(eventName, data)
  }

  function mount (selector) {
    var newTree = start()
    documentReady(function () {
      var root = document.querySelector(selector)
      assert.ok(root, 'choo.mount: could not query selector: ' + selector)
      nanomount(root, newTree)
      tree = root
    })
  }

  function toString (location, _state) {
    state = _state || {}
    var html = router(location)
    assert.equal()
    return html.toString()
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.choo.html" id="apidoc.element.choo.html">
        function <span class="apidocSignatureSpan">choo.</span>html
        <span class="apidocSignatureSpan">(strings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">html = function (strings) {
  var state = TEXT, reg = ''
  var arglen = arguments.length
  var parts = []

  for (var i = 0; i &lt; strings.length; i++) {
    if (i &lt; arglen - 1) {
      var arg = arguments[i+1]
      var p = parse(strings[i])
      var xstate = state
      if (xstate === ATTR_VALUE_DQ) xstate = ATTR_VALUE
      if (xstate === ATTR_VALUE_SQ) xstate = ATTR_VALUE
      if (xstate === ATTR_VALUE_W) xstate = ATTR_VALUE
      if (xstate === ATTR) xstate = ATTR_KEY
      p.push([ VAR, xstate, arg ])
      parts.push.apply(parts, p)
    } else parts.push.apply(parts, parse(strings[i]))
  }

  var tree = [null,{},[]]
  var stack = [[tree,-1]]
  for (var i = 0; i &lt; parts.length; i++) {
    var cur = stack[stack.length-1][0]
    var p = parts[i], s = p[0]
    if (s === OPEN &amp;&amp; /^\//.test(p[1])) {
      var ix = stack[stack.length-1][1]
      if (stack.length &gt; 1) {
        stack.pop()
        stack[stack.length-1][0][2][ix] = h(
          cur[0], cur[1], cur[2].length ? cur[2] : undefined
        )
      }
    } else if (s === OPEN) {
      var c = [p[1],{},[]]
      cur[2].push(c)
      stack.push([c,cur[2].length-1])
    } else if (s === ATTR_KEY || (s === VAR &amp;&amp; p[1] === ATTR_KEY)) {
      var key = ''
      var copyKey
      for (; i &lt; parts.length; i++) {
        if (parts[i][0] === ATTR_KEY) {
          key = concat(key, parts[i][1])
        } else if (parts[i][0] === VAR &amp;&amp; parts[i][1] === ATTR_KEY) {
          if (typeof parts[i][2] === 'object' &amp;&amp; !key) {
            for (copyKey in parts[i][2]) {
              if (parts[i][2].hasOwnProperty(copyKey) &amp;&amp; !cur[1][copyKey]) {
                cur[1][copyKey] = parts[i][2][copyKey]
              }
            }
          } else {
            key = concat(key, parts[i][2])
          }
        } else break
      }
      if (parts[i][0] === ATTR_EQ) i++
      var j = i
      for (; i &lt; parts.length; i++) {
        if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {
          if (!cur[1][key]) cur[1][key] = strfn(parts[i][1])
          else cur[1][key] = concat(cur[1][key], parts[i][1])
        } else if (parts[i][0] === VAR
        &amp;&amp; (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {
          if (!cur[1][key]) cur[1][key] = strfn(parts[i][2])
          else cur[1][key] = concat(cur[1][key], parts[i][2])
        } else {
          if (key.length &amp;&amp; !cur[1][key] &amp;&amp; i === j
          &amp;&amp; (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) {
            // https://html.spec.whatwg.org/multipage/infrastructure.html#boolean-attributes
            // empty string is falsy, not well behaved value in browser
            cur[1][key] = key.toLowerCase()
          }
          break
        }
      }
    } else if (s === ATTR_KEY) {
      cur[1][p[1]] = true
    } else if (s === VAR &amp;&amp; p[1] === ATTR_KEY) {
      cur[1][p[2]] = true
    } else if (s === CLOSE) {
      if (selfClosing(cur[0]) &amp;&amp; stack.length) {
        var ix = stack[stack.length-1][1]
        stack.pop()
        stack[stack.length-1][0][2][ix] = h(
          cur[0], cur[1], cur[2].length ? cur[2] : undefined
        )
      }
    } else if (s === VAR &amp;&amp; p[1] === TEXT) {
      if (p[2] === undefined || p[2] === null) p[2] = ''
      else if (!p[2]) p[2] = concat('', p[2])
      if (Array.isArray(p[2][0])) {
        cur[2].push.apply(cur[2], p[2])
      } else {
        cur[2].push(p[2])
      }
    } else if (s === TEXT) {
      cur[2].push(p[1])
    } else if (s === ATTR_EQ || s === ATTR_BREAK) {
      // no-op
    } else {
      throw new Error('unhandled: ' + s)
    }
  }

  if (tree[2].length &gt; 1 &amp;&amp; /^\s*$/.test(tree[2][0])) {
    tree[2].shift()
  }

  if (tree[2].length &gt; 2
  || (tree[2].length === 2 &amp;&amp; /\S/.test(tree[2][1]))) {
    throw new Error(
      'multiple root elements must be wrapped in an enclosing tag'
    )
  }
  if (Array.isArray(tree[2][0]) &amp;&amp; typeof tree[2][0][0] === 'string'
  &amp;&amp; Array.isArray(tree[2][0][2])) {
    tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2])
  }
  return tree[2][0]

  function parse (str) {
    var res = []
    if (state === ATTR_VALUE_W) sta ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.choo.html" id="apidoc.module.choo.html">module choo.html</a></h1>


    <h2>
        <a href="#apidoc.element.choo.html.html" id="apidoc.element.choo.html.html">
        function <span class="apidocSignatureSpan">choo.</span>html
        <span class="apidocSignatureSpan">(strings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">html = function (strings) {
  var state = TEXT, reg = ''
  var arglen = arguments.length
  var parts = []

  for (var i = 0; i &lt; strings.length; i++) {
    if (i &lt; arglen - 1) {
      var arg = arguments[i+1]
      var p = parse(strings[i])
      var xstate = state
      if (xstate === ATTR_VALUE_DQ) xstate = ATTR_VALUE
      if (xstate === ATTR_VALUE_SQ) xstate = ATTR_VALUE
      if (xstate === ATTR_VALUE_W) xstate = ATTR_VALUE
      if (xstate === ATTR) xstate = ATTR_KEY
      p.push([ VAR, xstate, arg ])
      parts.push.apply(parts, p)
    } else parts.push.apply(parts, parse(strings[i]))
  }

  var tree = [null,{},[]]
  var stack = [[tree,-1]]
  for (var i = 0; i &lt; parts.length; i++) {
    var cur = stack[stack.length-1][0]
    var p = parts[i], s = p[0]
    if (s === OPEN &amp;&amp; /^\//.test(p[1])) {
      var ix = stack[stack.length-1][1]
      if (stack.length &gt; 1) {
        stack.pop()
        stack[stack.length-1][0][2][ix] = h(
          cur[0], cur[1], cur[2].length ? cur[2] : undefined
        )
      }
    } else if (s === OPEN) {
      var c = [p[1],{},[]]
      cur[2].push(c)
      stack.push([c,cur[2].length-1])
    } else if (s === ATTR_KEY || (s === VAR &amp;&amp; p[1] === ATTR_KEY)) {
      var key = ''
      var copyKey
      for (; i &lt; parts.length; i++) {
        if (parts[i][0] === ATTR_KEY) {
          key = concat(key, parts[i][1])
        } else if (parts[i][0] === VAR &amp;&amp; parts[i][1] === ATTR_KEY) {
          if (typeof parts[i][2] === 'object' &amp;&amp; !key) {
            for (copyKey in parts[i][2]) {
              if (parts[i][2].hasOwnProperty(copyKey) &amp;&amp; !cur[1][copyKey]) {
                cur[1][copyKey] = parts[i][2][copyKey]
              }
            }
          } else {
            key = concat(key, parts[i][2])
          }
        } else break
      }
      if (parts[i][0] === ATTR_EQ) i++
      var j = i
      for (; i &lt; parts.length; i++) {
        if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {
          if (!cur[1][key]) cur[1][key] = strfn(parts[i][1])
          else cur[1][key] = concat(cur[1][key], parts[i][1])
        } else if (parts[i][0] === VAR
        &amp;&amp; (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {
          if (!cur[1][key]) cur[1][key] = strfn(parts[i][2])
          else cur[1][key] = concat(cur[1][key], parts[i][2])
        } else {
          if (key.length &amp;&amp; !cur[1][key] &amp;&amp; i === j
          &amp;&amp; (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) {
            // https://html.spec.whatwg.org/multipage/infrastructure.html#boolean-attributes
            // empty string is falsy, not well behaved value in browser
            cur[1][key] = key.toLowerCase()
          }
          break
        }
      }
    } else if (s === ATTR_KEY) {
      cur[1][p[1]] = true
    } else if (s === VAR &amp;&amp; p[1] === ATTR_KEY) {
      cur[1][p[2]] = true
    } else if (s === CLOSE) {
      if (selfClosing(cur[0]) &amp;&amp; stack.length) {
        var ix = stack[stack.length-1][1]
        stack.pop()
        stack[stack.length-1][0][2][ix] = h(
          cur[0], cur[1], cur[2].length ? cur[2] : undefined
        )
      }
    } else if (s === VAR &amp;&amp; p[1] === TEXT) {
      if (p[2] === undefined || p[2] === null) p[2] = ''
      else if (!p[2]) p[2] = concat('', p[2])
      if (Array.isArray(p[2][0])) {
        cur[2].push.apply(cur[2], p[2])
      } else {
        cur[2].push(p[2])
      }
    } else if (s === TEXT) {
      cur[2].push(p[1])
    } else if (s === ATTR_EQ || s === ATTR_BREAK) {
      // no-op
    } else {
      throw new Error('unhandled: ' + s)
    }
  }

  if (tree[2].length &gt; 1 &amp;&amp; /^\s*$/.test(tree[2][0])) {
    tree[2].shift()
  }

  if (tree[2].length &gt; 2
  || (tree[2].length === 2 &amp;&amp; /\S/.test(tree[2][1]))) {
    throw new Error(
      'multiple root elements must be wrapped in an enclosing tag'
    )
  }
  if (Array.isArray(tree[2][0]) &amp;&amp; typeof tree[2][0][0] === 'string'
  &amp;&amp; Array.isArray(tree[2][0][2])) {
    tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2])
  }
  return tree[2][0]

  function parse (str) {
    var res = []
    if (state === ATTR_VALUE_W) sta ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.choo.html.createElement" id="apidoc.element.choo.html.createElement">
        function <span class="apidocSignatureSpan">choo.html.</span>createElement
        <span class="apidocSignatureSpan">(tag, props, children)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function belCreateElement(tag, props, children) {
  var el

  // If an svg tag, it needs a namespace
  if (SVG_TAGS.indexOf(tag) !== -1) {
    props.namespace = SVGNS
  }

  // If we are using a namespace
  var ns = false
  if (props.namespace) {
    ns = props.namespace
    delete props.namespace
  }

  // Create the element
  if (ns) {
    el = document.createElementNS(ns, tag)
  } else if (tag === COMMENT_TAG) {
    return document.createComment(props.comment)
  } else {
    el = document.createElement(tag)
  }

  // If adding onload events
  if (props.onload || props.onunload) {
    var load = props.onload || function () {}
    var unload = props.onunload || function () {}
    onload(el, function belOnload () {
      load(el)
    }, function belOnunload () {
      unload(el)
    },
    // We have to use non-standard `caller` to find who invokes `belCreateElement`
    belCreateElement.caller.caller.caller)
    delete props.onload
    delete props.onunload
  }

  // Create the properties
  for (var p in props) {
    if (props.hasOwnProperty(p)) {
      var key = p.toLowerCase()
      var val = props[p]
      // Normalize className
      if (key === 'classname') {
        key = 'class'
        p = 'class'
      }
      // The for attribute gets transformed to htmlFor, but we just set as for
      if (p === 'htmlFor') {
        p = 'for'
      }
      // If a property is boolean, set itself to the key
      if (BOOL_PROPS[key]) {
        if (val === 'true') val = key
        else if (val === 'false') continue
      }
      // If a property prefers being set directly vs setAttribute
      if (key.slice(0, 2) === 'on') {
        el[p] = val
      } else {
        if (ns) {
          if (p === 'xlink:href') {
            el.setAttributeNS(XLINKNS, p, val)
          } else if (/^xmlns($|:)/i.test(p)) {
            // skip xmlns definitions
          } else {
            el.setAttributeNS(null, p, val)
          }
        } else {
          el.setAttribute(p, val)
        }
      }
    }
  }

  function appendChild (childs) {
    if (!Array.isArray(childs)) return
    for (var i = 0; i &lt; childs.length; i++) {
      var node = childs[i]
      if (Array.isArray(node)) {
        appendChild(node)
        continue
      }

      if (typeof node === 'number' ||
        typeof node === 'boolean' ||
        typeof node === 'function' ||
        node instanceof Date ||
        node instanceof RegExp) {
        node = node.toString()
      }

      if (typeof node === 'string') {
        if (el.lastChild &amp;&amp; el.lastChild.nodeName === '#text') {
          el.lastChild.nodeValue += node
          continue
        }
        node = document.createTextNode(node)
      }

      if (node &amp;&amp; node.nodeType) {
        el.appendChild(node)
      }
    }
  }
  appendChild(children)

  return el
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
look at how far you've come in the last month. You've grown... tinier? But yet
you do more? I love you `choo` - _shut up dad_.

### Notable changes
#### Who's the tiniest of them all?
`choo` is now `5kb` optimized! That's `2kb` less compared to v2. _Woah, how?_
We now support [yo-yoify](https://github.com/shama/yo-yoify) which optimizes
those lil template tags to `document.<span class="apidocCodeKeywordSpan">createElement</span>()` calls. So not only is it
smaller, creating elements now has no overhead. Pretty nifty eh? Mad shoutout
to [Shama](http://twitter.com/shamakry) for building this!

#### Captain Hook(s)
V3 introduces `hooks` - powerful functions that are called at certain points in
the refresh cycle. Unlike functions in `models` these functions have unfiltered
access to all properties, call stacks and more. They're super useful when
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.choo.html.default" id="apidoc.element.choo.html.default">
        function <span class="apidocSignatureSpan">choo.html.</span>default
        <span class="apidocSignatureSpan">(strings)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">default = function (strings) {
  var state = TEXT, reg = ''
  var arglen = arguments.length
  var parts = []

  for (var i = 0; i &lt; strings.length; i++) {
    if (i &lt; arglen - 1) {
      var arg = arguments[i+1]
      var p = parse(strings[i])
      var xstate = state
      if (xstate === ATTR_VALUE_DQ) xstate = ATTR_VALUE
      if (xstate === ATTR_VALUE_SQ) xstate = ATTR_VALUE
      if (xstate === ATTR_VALUE_W) xstate = ATTR_VALUE
      if (xstate === ATTR) xstate = ATTR_KEY
      p.push([ VAR, xstate, arg ])
      parts.push.apply(parts, p)
    } else parts.push.apply(parts, parse(strings[i]))
  }

  var tree = [null,{},[]]
  var stack = [[tree,-1]]
  for (var i = 0; i &lt; parts.length; i++) {
    var cur = stack[stack.length-1][0]
    var p = parts[i], s = p[0]
    if (s === OPEN &amp;&amp; /^\//.test(p[1])) {
      var ix = stack[stack.length-1][1]
      if (stack.length &gt; 1) {
        stack.pop()
        stack[stack.length-1][0][2][ix] = h(
          cur[0], cur[1], cur[2].length ? cur[2] : undefined
        )
      }
    } else if (s === OPEN) {
      var c = [p[1],{},[]]
      cur[2].push(c)
      stack.push([c,cur[2].length-1])
    } else if (s === ATTR_KEY || (s === VAR &amp;&amp; p[1] === ATTR_KEY)) {
      var key = ''
      var copyKey
      for (; i &lt; parts.length; i++) {
        if (parts[i][0] === ATTR_KEY) {
          key = concat(key, parts[i][1])
        } else if (parts[i][0] === VAR &amp;&amp; parts[i][1] === ATTR_KEY) {
          if (typeof parts[i][2] === 'object' &amp;&amp; !key) {
            for (copyKey in parts[i][2]) {
              if (parts[i][2].hasOwnProperty(copyKey) &amp;&amp; !cur[1][copyKey]) {
                cur[1][copyKey] = parts[i][2][copyKey]
              }
            }
          } else {
            key = concat(key, parts[i][2])
          }
        } else break
      }
      if (parts[i][0] === ATTR_EQ) i++
      var j = i
      for (; i &lt; parts.length; i++) {
        if (parts[i][0] === ATTR_VALUE || parts[i][0] === ATTR_KEY) {
          if (!cur[1][key]) cur[1][key] = strfn(parts[i][1])
          else cur[1][key] = concat(cur[1][key], parts[i][1])
        } else if (parts[i][0] === VAR
        &amp;&amp; (parts[i][1] === ATTR_VALUE || parts[i][1] === ATTR_KEY)) {
          if (!cur[1][key]) cur[1][key] = strfn(parts[i][2])
          else cur[1][key] = concat(cur[1][key], parts[i][2])
        } else {
          if (key.length &amp;&amp; !cur[1][key] &amp;&amp; i === j
          &amp;&amp; (parts[i][0] === CLOSE || parts[i][0] === ATTR_BREAK)) {
            // https://html.spec.whatwg.org/multipage/infrastructure.html#boolean-attributes
            // empty string is falsy, not well behaved value in browser
            cur[1][key] = key.toLowerCase()
          }
          break
        }
      }
    } else if (s === ATTR_KEY) {
      cur[1][p[1]] = true
    } else if (s === VAR &amp;&amp; p[1] === ATTR_KEY) {
      cur[1][p[2]] = true
    } else if (s === CLOSE) {
      if (selfClosing(cur[0]) &amp;&amp; stack.length) {
        var ix = stack[stack.length-1][1]
        stack.pop()
        stack[stack.length-1][0][2][ix] = h(
          cur[0], cur[1], cur[2].length ? cur[2] : undefined
        )
      }
    } else if (s === VAR &amp;&amp; p[1] === TEXT) {
      if (p[2] === undefined || p[2] === null) p[2] = ''
      else if (!p[2]) p[2] = concat('', p[2])
      if (Array.isArray(p[2][0])) {
        cur[2].push.apply(cur[2], p[2])
      } else {
        cur[2].push(p[2])
      }
    } else if (s === TEXT) {
      cur[2].push(p[1])
    } else if (s === ATTR_EQ || s === ATTR_BREAK) {
      // no-op
    } else {
      throw new Error('unhandled: ' + s)
    }
  }

  if (tree[2].length &gt; 1 &amp;&amp; /^\s*$/.test(tree[2][0])) {
    tree[2].shift()
  }

  if (tree[2].length &gt; 2
  || (tree[2].length === 2 &amp;&amp; /\S/.test(tree[2][1]))) {
    throw new Error(
      'multiple root elements must be wrapped in an enclosing tag'
    )
  }
  if (Array.isArray(tree[2][0]) &amp;&amp; typeof tree[2][0][0] === 'string'
  &amp;&amp; Array.isArray(tree[2][0][2])) {
    tree[2][0] = h(tree[2][0][0], tree[2][0][1], tree[2][0][2])
  }
  return tree[2][0]

  function parse (str) {
    var res = []
    if (state === ATTR_VALUE_W) sta ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>